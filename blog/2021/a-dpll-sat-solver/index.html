<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Writing a DPLL SAT Solver | Fan Pu Zeng </title> <meta name="author" content="Fan Pu Zeng"> <meta name="description" content="Boolean satisfiability (SAT) solvers have played an important role in software and hardware verification, automatic test pattern generation, planning, scheduling, and solving challenging problems in algebra. In this post, I talk about my experience writing my own SAT solver, its implementation details, designs and algorithms used, some comparisons between using different heuristics for splitting and choosing of variable assignments in the unforced case, challenges faced, and possible future directions. "> <meta name="keywords" content="fanpu, fan pu, fanpu zeng, fan pu zeng, zengfanpu, fanpuzeng, fzeng, CMU, cmu, carnegie mellon, cmu courses, school of computer science, scs, machine learning, computer science, ml, theory, courses, course reviews, CS, Jane Street"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="/assets/img/favicon_new.ico?426605099301e95aedae716cc398b951"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://fanpu.io/blog/2021/a-dpll-sat-solver/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Fan Pu</span> Zeng </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/courses/">CMU Course Reviews </a> </li> <li class="nav-item "> <a class="nav-link" href="/cmu-online/">CMU Online </a> </li> <li class="nav-item "> <a class="nav-link" href="/summaries/">ML Paper Summaries </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">Writing a DPLL SAT Solver</h1> <p class="post-meta"> Created in May 18, 2021 by fanpu </p> <p class="post-tags"> <a href="/blog/2021"> <i class="fa-solid fa-calendar fa-sm"></i> 2021 </a>   ·   <a href="/blog/tag/code"> <i class="fa-solid fa-hashtag fa-sm"></i> code</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p>Boolean satisfiability (SAT) solvers have played an important role in software and hardware verification, automatic test pattern generation, planning, scheduling, and solving challenging problems in algebra.</p> <p>In this post, I talk about my experience writing my own SAT solver, its implementation details, designs and algorithms used, some comparisons between using different heuristics for splitting and choosing of variable assignments in the unforced case, challenges faced, and possible future directions.</p> <p>You can find <a href="https://github.com/fanpu/DPLL_SATSolver" rel="external nofollow noopener" target="_blank">the code for the project on Github here</a>.</p> <h2 id="overview">Overview</h2> <p>My SAT solver uses the classical Davis–Putnam–Logemann–Loveland (DPLL) algorithm, which is based off backtracking search. In order to speed up the search process, unit propagation (also known as boolean constraint propagation), and the usage of watchlists for ease of backtracking is also implemented.</p> <h2 id="trying-it-out">Trying it out</h2> <p>You can skip this section if you don’t intend to run the SAT solver and just want to learn more about how it is implemented.</p> <p>To run the SAT solver, run <code class="language-plaintext highlighter-rouge">./src/sat.py &lt;filename&gt;</code>. It also takes in verbosity flags, <code class="language-plaintext highlighter-rouge">-v</code> and <code class="language-plaintext highlighter-rouge">-vv</code> depending on the level desired. By default, only the test case being run and the result is given as output. <code class="language-plaintext highlighter-rouge">-v</code> prints the initial SAT formula, the current decisions being made and whenever backtracking is performed. It also outputs the final satisfying assignment. For instance, try running <code class="language-plaintext highlighter-rouge">./src/sat.py -v dat/sat/uf50-0100.cnf</code> to see the assignments for one of the test cases. <code class="language-plaintext highlighter-rouge">-vv</code> outputs almost all information about what the algorithm is currently doing.</p> <p>As an example, try running <code class="language-plaintext highlighter-rouge">./src/sat.py small/small-sat1.cnf</code>, which corresponds to the CNF \((x_1 \vee x_2 \vee x_3) \wedge (\neg x_1 \vee \neg x_2 \vee \neg x_3)\), which should output \(\texttt{SATISFIABLE}\). For an unsatisfiable instance, try running <code class="language-plaintext highlighter-rouge">./src/sat.py small/small-unsat2.cnf</code>, which is an unsatisfiable instance corresponding to the following SAT instance:</p> \[\begin{align*} &amp; (\neg x_1, x_2, x_4) \wedge (\neg x_2, x_3, x_4) \wedge ( x_1, \neg x_3, x_4) \wedge ( x_1, \neg x_2, \neg x_4) \wedge \\ &amp; ( x_2, \neg x_3, \neg x_4) \wedge (\neg x_1, x_3, \neg x_4) \wedge ( x_1, x_2, x_3) \wedge (\neg x_1, \neg x_2, \neg x_3) \end{align*}\] <p>This should output \(\texttt{UNSATISFIABLE}\).</p> <h2 id="algorithms">Algorithms</h2> <p>The two interesting algorithms implemented for SAT solving are DPLL and unit propagation. The DPLL forms the main logic of assigning variables and performing backtracking and re-assignment if conflict arise. Unit propagation is an optimization that helps us prune our search space and converge to a solution if any faster. We examine both in detail.</p> <h3 id="dpll">DPLL</h3> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/screenshots/dpll_algo.webp-480.webp 480w, /assets/img/screenshots/dpll_algo.webp-800.webp 800w, /assets/img/screenshots/dpll_algo.webp-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/screenshots/dpll_algo.webp" class="z-depth-1" width="700px" height="auto" style="object-fit: cover" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture><figcaption class="caption"> DPLL algorithm pseudocode </figcaption> </figure> <p>The DPLL algorithm works as follows: at every step, it chooses a variable to assign, and also chooses what value to first try assigning it. Whenever it makes such a voluntary assignment (i.e not forced), a new decision level is created. A decision level contains all the current assignments, and the variable that created the decision level. In our code, this is handled by the \(\texttt{Assignment}\) class, and the \(\texttt{assignment_stack}\) keeps track of the decision levels.</p> <p>Once a new decision level is created, we perform unit propagation (elaborated next). Unit propagation forces assignments, so there is no need to create new decision levels. If unit propagation results in conflicts (i.e a clause that is unsatisfiable for sure given the current assignments), we need to backtrack. Backtracking involves returning to the previous decision level, and forcing the assignment of the variable that caused the conflicting decision level to the negation of its previous assignment. If we ever run out of decision levels, it means that all possible choices of assignments results in conflicts, and therefore the SAT instance is unsatisfiable. By using decision levels (and also watchlists, elaborated later), we can write our code in an iterative instead of recursive manner, which is significantly faster as it avoids the overhead of moving around stack frames.</p> <p>In the DPLL algorithm, we allow the user to specify their own heuristics for both choosing the splitting variable, and the initial first assignment to use. This can be done by modifying \(\texttt{choose_splitting_var}\) and \(\texttt{choose_assn}\) in \(\texttt{heuristics.py}\) respectively. The file is well-documented and contains information on the information that is passed in that can be used to write a useful heuristic.</p> <p>By default, if either function throws \(\texttt{NotImplementedError}\), the SAT solver will choose the first unassigned variable, and default to trying to assign it to true first. The sample implementation given in \(\texttt{heuristics.py}\) uses a randomized strategy for both \(\texttt{choose_splitting_var}\) and \(\texttt{choose_assn}\), and is meant to demonstrate how the arguments can be used.</p> <h3 id="unit-propagation">Unit Propagation</h3> <p>The idea behind unit propagation is that when we have all other vars in a clause evaluating to false except one, then the final one must be set such that it evaluates to true. This is a forced assignment. This allows for great speedups as the search space can be drastically reduced.</p> <p>Instead of naively inspecting every clause during unit propagation which is costly, we can instead only examine clauses that are actually affected by assignments. In particular, we only care about clauses that contains vars whose corresponding variables are assigned a value that makes it evaluate to false. For instance, in the clause \((x_1 \vee x_2 \vee x_3)\) we can continue to sleep peacefully \(x_1\) was assigned to true, but we definitely will be concerned if \(x_1\) was assigned to be false.</p> <p>To this end, we introduce the idea of watched literals introduced by Moskewicz et al. Each clause contains a watchlist, which contains two variables that it is currently watching. It is initialized to be the first two variables. The requirements are that we must always have at least one of the variables that it is watching be non-false (i.e either true or unknown). Whenever this is violated, the clause must find another variable to watch. If this is not possible, then unit propagation returns \(\texttt{CONFLICT}\).</p> <p>Another benefit of using watched literals is that during backtracking, our constraints can only be relaxed (i.e our variables can be unassigned but never assigned), and therefore we do not need to update them.</p> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/screenshots/unit_propagation_algo.webp-480.webp 480w, /assets/img/screenshots/unit_propagation_algo.webp-800.webp 800w, /assets/img/screenshots/unit_propagation_algo.webp-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/screenshots/unit_propagation_algo.webp" class="z-depth-1" width="700px" height="auto" style="object-fit: cover" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture><figcaption class="caption"> Unit propagation algorithm pseudocode </figcaption> </figure> <p>In the unit propagation algorithm given above, we go through each of the vars that is now false as a result of previous assignments, and look at all the clauses watching them, and try to maintain the invariant that each clause is watching at least one non-False variable. If this is not possible and the other variable \(y\) being watched is an unknown, we then know we can force it to be true. If \(y\) is already assigned, then we have a conflict, and backtracking is inevitable.</p> <h2 id="experiments-with-various-heuristics">Experiments with various Heuristics</h2> <p>The SAT solving framework provides flexibility for changing the heuristics used easily. I ran some tests to see how well they performed relative to each other, with three different strategies:</p> <ol> <li>Default strategy: use first unassigned variable, and always assign True first</li> <li>Randomized strategy: use any unassigned variable, and use random initial truth values</li> <li>Majority strategy: use first unassigned variable, and assign it the value that will satisfy the majority of the clauses that it appears in</li> </ol> <p>The results are given below:</p> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/screenshots/sat_solver_heuristic_results.webp-480.webp 480w, /assets/img/screenshots/sat_solver_heuristic_results.webp-800.webp 800w, /assets/img/screenshots/sat_solver_heuristic_results.webp-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/screenshots/sat_solver_heuristic_results.webp" class="z-depth-1" width="400px" height="auto" style="object-fit: cover" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture><figcaption class="caption"> SAT solver heuristic comparisons </figcaption> </figure> <p>It is surprising that the random strategy runs much slower than the default strategy and the majority strategy. It is also surprising that the default naive strategy actually performs the best in this case, even though intuitively the majority strategy should perform better. A possible explanation for this behavior is that the majority strategy is a greedy strategy, and therefore random SAT instances could be resistant to greedy strategies.</p> <h2 id="future-directions">Future Directions</h2> <p>There are many other promising optimizations that can be added to improve the speed of this SAT solver.</p> <p>One possibility is to implement conflict-driven clause learning (CDCL) introduced by Marques et al, which is an extension of DPLL where it remembers conflicts that occurred previously and uses that to learn new clauses. This helps to prune the search space. We can also consider extending CDCL with random restarts, which has shown good results in practice. Random restarts has been shown to allow CDCL to learn about persistently troublesome conflicting variables earlier, and therefore converges to a solution faster.</p> <p>Another direction is to improve our heuristics for choosing variables and their values. MOMS (Maximum Occurence in clauses of Minimum Size) is a heuristic where we prioritize assigning variables that occurs the highest number of times in short clauses. Bohm’s heuristic chooses the variable that appears the most in unsatisfied clauses. The VSIDS (Variable State Independent Decaying Sum) heuristic assigns each variable a weight, which is decayed at each time step. The weight of a variable is increased whenever it is involved in a conflicting clause. The heuristic then selects the variable with the highest score.</p> <p>Other directions include using conflict-directed backjumping, which allows the solver to go more than one level up the decision level given certain conditions. Backjumping is a general technique used to speed up backtracking algorithms.</p> <h2 id="running-test-cases">Running Test Cases</h2> <p>You can skip this section unless you are playing around with the code. Running <code class="language-plaintext highlighter-rouge">make setup</code> will generate the testcases directory. The testcases are taken from <a href="https://www.cs.ubc.ca/~hoos/SATLIB/benchm.html" rel="external nofollow noopener" target="_blank">SATLIB</a>, and are split into two folders - <code class="language-plaintext highlighter-rouge">dat/sat</code> and <code class="language-plaintext highlighter-rouge">dat/unsat</code>, for satisfiable and unsatisfiable instances respectively. Each directory contains 1000 SAT instances, each of which contains 50 variable and 218 clauses. SATLIB claims that these instances are generated uniform at random.</p> <p>To run the SAT solver on all the instances that should be satisfiable, run <code class="language-plaintext highlighter-rouge">make sat</code>. This will take a while (around 10 minutes). To run unsatisfiable instances, run <code class="language-plaintext highlighter-rouge">make unsat</code>. This will take even longer.</p> <h2 id="closing-thoughts">Closing Thoughts</h2> <p>Writing the SAT sovler was a fun adventure. Maintaining the watched literals for each clause correctly was much trickier than I expected, and I had to write a few debugging routines and put assertions to diagnose and fix a few bugs (see <code class="language-plaintext highlighter-rouge">check_invariants</code> in <code class="language-plaintext highlighter-rouge">sat.py</code>). Debugging was also challenging because the SAT solver always performed correctly on my small hand-crafted SAT instances, and only failed on the much larger testcases from SATLIB which is far more difficult to trace. It also took me a while to initially convince myself of the correctness of the algorithm from the interplay between the propagation queue, the watched literals, and the decision levels, even though it seems completely obvious to me now.</p> <p>I hope you’ve found this post interesting and learned a thing or two. Let me know what you think in the comments!</p> <h2 id="references">References</h2> <ul> <li>Frank Van Harmelen, Vladimir Lifschitz, and Bruce Porter. <em>Handbook of knowledge representation</em>. Elsevier, 2010.</li> <li>Jediah Katz. Algorithms for SAT.</li> <li>Swords. Basics of SAT Solving Algorithms, Dec 2008.</li> <li>M.w. Moskewicz, C.f. Madigan, Y. Zhao, L. Zhang, and S. Malik. Chaff: Engineering an Efficient SAT Solver. <em>Proceedings of the 38th Design Automation Conference (IEEE Cat. No.01CH37232)</em>.</li> <li> <em>Handbook of satisfiability</em>. IOS Press, 2009.</li> <li>Carla Gomes, Bart Selman, and Henry Kautz. Boosting combinatorial search through randomization. <em>Proceedings of the National Conference on Artificial Intelligence</em>, 03 2003.</li> <li>Richard M. Stallman and Gerald J. Sussman. Forward reasoning and dependency-directed backtracking in a system for computer-aided circuit analysis. <em>Artificial Intelligence</em>, 9(2):135–196, 1977</li> </ul> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <p class="mb-2">Related Posts:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/llama-3.1-technical-report-notes/">Notes on 'The Llama 3 Herd of Models'</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/setting-up-yuancon-controller-sound-voltex/">Playing Sound Voltex at Home: Setting Up Unnamed SDVX Clone with the Yuancon SDVX Controller</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/creating-trackback-requests/">Creating Trackback Requests for Static Sites</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/high-dimensional-analysis-of-m-estimators/">A Unified Framework for High-Dimensional Analysis of M-Estimators with Decomposable Regularizers: A Guided Walkthrough</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/cmu-steam-tunnels/">The CMU Steam Tunnels and Wean 9</a> </li> <div id="giscus_thread" style="max-width: 930px; margin: 0 auto;"> <script>
      let giscusTheme = determineComputedTheme();
      let giscusAttributes = {
        src: 'https://giscus.app/client.js',
        'data-repo': 'fanpu/fanpu.github.io',
        'data-repo-id': '',
        'data-category': 'Comments',
        'data-category-id': '',
        'data-mapping': 'title',
        'data-strict': '1',
        'data-reactions-enabled': '1',
        'data-emit-metadata': '0',
        'data-input-position': 'bottom',
        'data-theme': giscusTheme,
        'data-lang': 'en',
        crossorigin: 'anonymous',
        async: '',
      };

      let giscusScript = document.createElement('script');
      Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value));
      document.getElementById('giscus_thread').appendChild(giscusScript);
    </script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Fan Pu Zeng. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Last updated: January 01, 2025. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script src="/assets/js/tooltips-setup.js?53023e960fbc64cccb90d32e9363de2b"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?70d799092f862ad98c7876aa47712e20"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-S3VHEYH05S"></script> <script defer src="/assets/js/google-analytics-setup.js?12374742c4b1801ba82226e617af7e2d"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>