<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Efficient Low Rank Approximation via Affine Embeddings | Fan Pu Zeng </title> <meta name="author" content="Fan Pu Zeng"> <meta name="description" content="Suppose you have a \(n \times d\) matrix \(A\), where both dimensions are large. This could represent something like a customer-product matrix used in online recommender systems, where each cell \(A_{i,j}\) denotes how many times customer \(i\) purchased item \(j\). Then it is typically the case that \(A\) can be well-approximated by a low-rank matrix. For instance, using the previous example, there might only be a few dominant patterns that describes purchasing behavior in \(A\), and the rest of it is just noise. Therefore, if we can find such a low-rank approximation, we can achieve significant space savings, and can also help to make the data more interpretable. In this post, we explore how affine embeddings via the CountSketch matrix allows us to perform low rank approximation in time \(O\left(\nnz{A}+(n+d) \text{poly} \left( \frac{k}{\epsilon} \right)\right)\). "> <meta name="keywords" content="fanpu, fan pu, fanpu zeng, fan pu zeng, zengfanpu, fanpuzeng, fzeng, CMU, cmu, carnegie mellon, cmu courses, school of computer science, scs, machine learning, computer science, ml, theory, courses, course reviews, CS, Jane Street"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="/assets/img/favicon_new.ico?426605099301e95aedae716cc398b951"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://fanpu.io/blog/2022/affine-embeddings-for-low-rank-approximation/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Fan Pu</span> Zeng </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/courses/">CMU Course Reviews </a> </li> <li class="nav-item "> <a class="nav-link" href="/cmu-online/">CMU Online </a> </li> <li class="nav-item "> <a class="nav-link" href="/summaries/">ML Paper Summaries </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <div class="post"> <div style="display:none"> $$ \newcommand{\bone}{\mathbf{1}} \newcommand{\bbeta}{\mathbf{\beta}} \newcommand{\bdelta}{\mathbf{\delta}} \newcommand{\bepsilon}{\mathbf{\epsilon}} \newcommand{\blambda}{\mathbf{\lambda}} \newcommand{\bomega}{\mathbf{\omega}} \newcommand{\bpi}{\mathbf{\pi}} \newcommand{\bphi}{\mathbf{\phi}} \newcommand{\bvphi}{\mathbf{\varphi}} \newcommand{\bpsi}{\mathbf{\psi}} \newcommand{\bsigma}{\mathbf{\sigma}} \newcommand{\btheta}{\mathbf{\theta}} \newcommand{\btau}{\mathbf{\tau}} \newcommand{\ba}{\mathbf{a}} \newcommand{\bb}{\mathbf{b}} \newcommand{\bc}{\mathbf{c}} \newcommand{\bd}{\mathbf{d}} \newcommand{\be}{\mathbf{e}} \newcommand{\boldf}{\mathbf{f}} \newcommand{\bg}{\mathbf{g}} \newcommand{\bh}{\mathbf{h}} \newcommand{\bi}{\mathbf{i}} \newcommand{\bj}{\mathbf{j}} \newcommand{\bk}{\mathbf{k}} \newcommand{\bell}{\mathbf{\ell}} \newcommand{\bm}{\mathbf{m}} \newcommand{\bn}{\mathbf{n}} \newcommand{\bo}{\mathbf{o}} \newcommand{\bp}{\mathbf{p}} \newcommand{\bq}{\mathbf{q}} \newcommand{\br}{\mathbf{r}} \newcommand{\bs}{\mathbf{s}} \newcommand{\bt}{\mathbf{t}} \newcommand{\bu}{\mathbf{u}} \newcommand{\bv}{\mathbf{v}} \newcommand{\bw}{\mathbf{w}} \newcommand{\bx}{\mathbf{x}} \newcommand{\by}{\mathbf{y}} \newcommand{\bz}{\mathbf{z}} \newcommand{\bA}{\mathbf{A}} \newcommand{\bB}{\mathbf{B}} \newcommand{\bC}{\mathbf{C}} \newcommand{\bD}{\mathbf{D}} \newcommand{\bE}{\mathbf{E}} \newcommand{\bF}{\mathbf{F}} \newcommand{\bG}{\mathbf{G}} \newcommand{\bH}{\mathbf{H}} \newcommand{\bI}{\mathbf{I}} \newcommand{\bJ}{\mathbf{J}} \newcommand{\bK}{\mathbf{K}} \newcommand{\bL}{\mathbf{L}} \newcommand{\bM}{\mathbf{M}} \newcommand{\bN}{\mathbf{N}} \newcommand{\bP}{\mathbf{P}} \newcommand{\bQ}{\mathbf{Q}} \newcommand{\bR}{\mathbf{R}} \newcommand{\bS}{\mathbf{S}} \newcommand{\bT}{\mathbf{T}} \newcommand{\bU}{\mathbf{U}} \newcommand{\bV}{\mathbf{V}} \newcommand{\bW}{\mathbf{W}} \newcommand{\bX}{\mathbf{X}} \newcommand{\bY}{\mathbf{Y}} \newcommand{\bZ}{\mathbf{Z}} \newcommand{\bsa}{\boldsymbol{a}} \newcommand{\bsb}{\boldsymbol{b}} \newcommand{\bsc}{\boldsymbol{c}} \newcommand{\bsd}{\boldsymbol{d}} \newcommand{\bse}{\boldsymbol{e}} \newcommand{\bsoldf}{\boldsymbol{f}} \newcommand{\bsg}{\boldsymbol{g}} \newcommand{\bsh}{\boldsymbol{h}} \newcommand{\bsi}{\boldsymbol{i}} \newcommand{\bsj}{\boldsymbol{j}} \newcommand{\bsk}{\boldsymbol{k}} \newcommand{\bsell}{\boldsymbol{\ell}} \newcommand{\bsm}{\boldsymbol{m}} \newcommand{\bsn}{\boldsymbol{n}} \newcommand{\bso}{\boldsymbol{o}} \newcommand{\bsp}{\boldsymbol{p}} \newcommand{\bsq}{\boldsymbol{q}} \newcommand{\bsr}{\boldsymbol{r}} \newcommand{\bss}{\boldsymbol{s}} \newcommand{\bst}{\boldsymbol{t}} \newcommand{\bsu}{\boldsymbol{u}} \newcommand{\bsv}{\boldsymbol{v}} \newcommand{\bsw}{\boldsymbol{w}} \newcommand{\bsx}{\boldsymbol{x}} \newcommand{\bsy}{\boldsymbol{y}} \newcommand{\bsz}{\boldsymbol{z}} \newcommand{\bsA}{\boldsymbol{A}} \newcommand{\bsB}{\boldsymbol{B}} \newcommand{\bsC}{\boldsymbol{C}} \newcommand{\bsD}{\boldsymbol{D}} \newcommand{\bsE}{\boldsymbol{E}} \newcommand{\bsF}{\boldsymbol{F}} \newcommand{\bsG}{\boldsymbol{G}} \newcommand{\bsH}{\boldsymbol{H}} \newcommand{\bsI}{\boldsymbol{I}} \newcommand{\bsJ}{\boldsymbol{J}} \newcommand{\bsK}{\boldsymbol{K}} \newcommand{\bsL}{\boldsymbol{L}} \newcommand{\bsM}{\boldsymbol{M}} \newcommand{\bsN}{\boldsymbol{N}} \newcommand{\bsP}{\boldsymbol{P}} \newcommand{\bsQ}{\boldsymbol{Q}} \newcommand{\bsR}{\boldsymbol{R}} \newcommand{\bsS}{\boldsymbol{S}} \newcommand{\bsT}{\boldsymbol{T}} \newcommand{\bsU}{\boldsymbol{U}} \newcommand{\bsV}{\boldsymbol{V}} \newcommand{\bsW}{\boldsymbol{W}} \newcommand{\bsX}{\boldsymbol{X}} \newcommand{\bsY}{\boldsymbol{Y}} \newcommand{\bsZ}{\boldsymbol{Z}} \newcommand{\calA}{\mathcal{A}} \newcommand{\calB}{\mathcal{B}} \newcommand{\calC}{\mathcal{C}} \newcommand{\calD}{\mathcal{D}} \newcommand{\calE}{\mathcal{E}} \newcommand{\calF}{\mathcal{F}} \newcommand{\calG}{\mathcal{G}} \newcommand{\calH}{\mathcal{H}} \newcommand{\calI}{\mathcal{I}} \newcommand{\calJ}{\mathcal{J}} \newcommand{\calK}{\mathcal{K}} \newcommand{\calL}{\mathcal{L}} \newcommand{\calM}{\mathcal{M}} \newcommand{\calN}{\mathcal{N}} \newcommand{\calO}{\mathcal{O}} \newcommand{\calP}{\mathcal{P}} \newcommand{\calQ}{\mathcal{Q}} \newcommand{\calR}{\mathcal{R}} \newcommand{\calS}{\mathcal{S}} \newcommand{\calT}{\mathcal{T}} \newcommand{\calU}{\mathcal{U}} \newcommand{\calV}{\mathcal{V}} \newcommand{\calW}{\mathcal{W}} \newcommand{\calX}{\mathcal{X}} \newcommand{\calY}{\mathcal{Y}} \newcommand{\calZ}{\mathcal{Z}} \newcommand{\R}{\mathbb{R}} \newcommand{\C}{\mathbb{C}} \newcommand{\N}{\mathbb{N}} \newcommand{\Z}{\mathbb{Z}} \newcommand{\F}{\mathbb{F}} \newcommand{\Q}{\mathbb{Q}} \DeclareMathOperator*{\argmax}{arg\,max} \DeclareMathOperator*{\argmin}{arg\,min} \newcommand{\nnz}[1]{\mbox{nnz}(#1)} \newcommand{\dotprod}[2]{\langle #1, #2 \rangle} \newcommand{\ignore}[1]{} \let\Pr\relax \DeclareMathOperator*{\Pr}{\mathbf{Pr}} \newcommand{\E}{\mathbb{E}} \DeclareMathOperator*{\Ex}{\mathbf{E}} \DeclareMathOperator*{\Var}{\mathbf{Var}} \DeclareMathOperator*{\Cov}{\mathbf{Cov}} \DeclareMathOperator*{\stddev}{\mathbf{stddev}} \DeclareMathOperator*{\avg}{avg} \DeclareMathOperator{\poly}{poly} \DeclareMathOperator{\polylog}{polylog} \DeclareMathOperator{\size}{size} \DeclareMathOperator{\sgn}{sgn} \DeclareMathOperator{\dist}{dist} \DeclareMathOperator{\vol}{vol} \DeclareMathOperator{\spn}{span} \DeclareMathOperator{\supp}{supp} \DeclareMathOperator{\tr}{tr} \DeclareMathOperator{\Tr}{Tr} \DeclareMathOperator{\codim}{codim} \DeclareMathOperator{\diag}{diag} \newcommand{\PTIME}{\mathsf{P}} \newcommand{\LOGSPACE}{\mathsf{L}} \newcommand{\ZPP}{\mathsf{ZPP}} \newcommand{\RP}{\mathsf{RP}} \newcommand{\BPP}{\mathsf{BPP}} \newcommand{\P}{\mathsf{P}} \newcommand{\NP}{\mathsf{NP}} \newcommand{\TC}{\mathsf{TC}} \newcommand{\AC}{\mathsf{AC}} \newcommand{\SC}{\mathsf{SC}} \newcommand{\SZK}{\mathsf{SZK}} \newcommand{\AM}{\mathsf{AM}} \newcommand{\IP}{\mathsf{IP}} \newcommand{\PSPACE}{\mathsf{PSPACE}} \newcommand{\EXP}{\mathsf{EXP}} \newcommand{\MIP}{\mathsf{MIP}} \newcommand{\NEXP}{\mathsf{NEXP}} \newcommand{\BQP}{\mathsf{BQP}} \newcommand{\distP}{\mathsf{dist\textbf{P}}} \newcommand{\distNP}{\mathsf{dist\textbf{NP}}} \newcommand{\eps}{\epsilon} \newcommand{\lam}{\lambda} \newcommand{\dleta}{\delta} \newcommand{\simga}{\sigma} \newcommand{\vphi}{\varphi} \newcommand{\la}{\langle} \newcommand{\ra}{\rangle} \newcommand{\wt}[1]{\widetilde{#1}} \newcommand{\wh}[1]{\widehat{#1}} \newcommand{\ol}[1]{\overline{#1}} \newcommand{\ul}[1]{\underline{#1}} \newcommand{\ot}{\otimes} \newcommand{\zo}{\{0,1\}} \newcommand{\co}{:} %\newcommand{\co}{\colon} \newcommand{\bdry}{\partial} \newcommand{\grad}{\nabla} \newcommand{\transp}{^\intercal} \newcommand{\inv}{^{-1}} \newcommand{\symmdiff}{\triangle} \newcommand{\symdiff}{\symmdiff} \newcommand{\half}{\tfrac{1}{2}} \newcommand{\bbone}{\mathbbm 1} \newcommand{\Id}{\bbone} \newcommand{\SAT}{\mathsf{SAT}} \newcommand{\bcalG}{\boldsymbol{\calG}} \newcommand{\calbG}{\bcalG} \newcommand{\bcalX}{\boldsymbol{\calX}} \newcommand{\calbX}{\bcalX} \newcommand{\bcalY}{\boldsymbol{\calY}} \newcommand{\calbY}{\bcalY} \newcommand{\bcalZ}{\boldsymbol{\calZ}} \newcommand{\calbZ}{\bcalZ} $$ </div> <header class="post-header"> <h1 class="post-title">Efficient Low Rank Approximation via Affine Embeddings</h1> <p class="post-meta"> Created in September 29, 2022 by fanpu </p> <p class="post-tags"> <a href="/blog/2022"> <i class="fa-solid fa-calendar fa-sm"></i> 2022 </a>   ·   <a href="/blog/tag/theory"> <i class="fa-solid fa-hashtag fa-sm"></i> theory</a>   <a href="/blog/tag/machine-learning"> <i class="fa-solid fa-hashtag fa-sm"></i> machine-learning</a>   <a href="/blog/tag/math"> <i class="fa-solid fa-hashtag fa-sm"></i> math</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h3 id="affine-embeddings">Affine Embeddings</h3> <p>Suppose we have a \(n \times d\) matrix \(A\) that is tall and thin, and a \(n \times m\) matrix \(B\) that can have a very large number of columns. The goal is to solve</p> \[\begin{equation} \min_X | AX - B|_F^2. \end{equation}\] <p>An affine embedding is a matrix \(S\) such that</p> \[\begin{equation} \label{eq:affine_desired} \|S(A X-B)\|_{\mathrm{F}}=(1 \pm \varepsilon)\|A X-B\|_{\mathrm{F}} \end{equation}\] <p>holds with high probability. CountSketch matrices are one class of matrices that can be used for affine embeddings. CountSketch matrices are \(k \times n\) matrices with \(k = O(d^2/\varepsilon^2)\), and where one entry is taken per column at random and set to \(\pm 1\) with equal probability, with all other entries zero.</p> <p>For the rest of this post, we will see how to apply affine embeddings to help solve low-rank approximations.</p> <h3 id="low-rank-approximation">Low-Rank Approximation</h3> <p>Low-rank approximation is also referred to as Principal Component Analysis (PCA). It is one of the most popular ways of performing linear dimensionality reduction, with other more complicated ways being via neural networks.</p> <h3 id="motivation">Motivation</h3> <p>Suppose you have a \(n \times d\) matrix \(A\), where both dimensions are large. This could represent something like a customer-product matrix used in online recommender systems, where each cell \(A_{i,j}\) denotes how many times customer \(i\) purchased item \(j\). Then it is typically the case that \(A\) can be well-approximated by a low-rank matrix. For instance, using the previous example, there might only be a few dominant patterns that describes purchasing behavior in \(A\), and the rest of it is just noise.</p> <p>Therefore, if we can find such a low-rank approximation, we can achieve significant space savings, and can also help to make the data more interpretable.</p> <p>We can thus formulate our problem as finding a rank-\(k\) matrix \(A_k\) such that</p> \[\begin{equation}\label{eq:best-rank-k} \argmin_{\text {rank-$k$ matrices $B$} }\|A - B\|_{\mathrm{F}} \end{equation}\] <h3 id="exact-solution-truncated-singular-value-decomposition">Exact Solution: Truncated Singular Value Decomposition</h3> <p>A natural solution that comes to mind is to use truncated singular value decomposition (SVD), which in fact gives us the best rank-\(k\) approximation for \(A\) as per Equation \ref{eq:best-rank-k}. To approximate the \(n \times d\) matrix \(A\) with a rank-\(k\) matrix, compute the SVD of \(A\) to get \(A=U \Sigma V^{\top}\). Define \(\Sigma_{k}\) by zeroing out all the singular values in \(\Sigma\) below the \(k\)-th row, and define \(A_{k}=U \Sigma_{k} V^{\top}\). Note that we can also drop all but the top \(k\) rows or \(V^{\top}\) and drop all but the top \(k\) columns of \(U\) without changing \(A_{k}\).</p> <p>It turns out that \(A_{k}\) minimizes \(\left\|A_{k}-A\right\|\) among all rank-\(k\) matrices for many norms, including the Frobenius norm and the spectral norm. More generally, \(A_{k}\) is the best rank-\(k\) approximation under any unitarily invariant norm.</p> <p>We can compute the SVD of \(A\) in \(O\left(\min \left(n d^{2}, n^{2} d\right)\right)\) time. The \(\min\) comes from the fact that we can transpose \(A\) if necessary before performing SVD, so that the linear dimension matches the larger dimension.</p> <p>However, the problem is that performing SVD is too expensive, since \(n\) and \(d\) are large.</p> <h3 id="approximate-solution-truncated-singular-value-decomposition">Approximate Solution: Truncated Singular Value Decomposition</h3> <p>In order to get a better runtime, we relax the problem such that we are satisfied with an approximate solution instead of an exact solution. Our goal is now to find a rank \(k\) matrix \(A'\) such that</p> \[\begin{equation} \left\|A^{\prime}-A\right\|_F \leq(1+\varepsilon)\left\|A_{k}-A\right\|_F \end{equation}\] <p>with a constant failure probability (say 9/10).</p> <p>We will now show an algorithm that can do this \({O(\nnz{A} +(n+d) \operatorname{poly}(k / \varepsilon))}\) time, due to Woodruff, Clarkson, and Sarlos~\cite{Woodruff-LRA}~\cite{sarlos}. Recall that \(\nnz{A}\) is the number of non-zero entries in \(A\). When the input is dense, this is in approximately \(O(n d)\) time, which is significantly faster than SVD. When it is sparse, it becomes even faster.</p> <h3 id="intuition">Intuition</h3> <p>The key idea is to compute \(SA\), such that the number of rows of \(S\) is \(O(k/\epsilon)\) which is small.</p> <p>Think of the rows of \(A\) as points in \(\mathbb{R}^d\). Think of \(SA\) as taking a small number of linear combinations of \(A\), where each row of \(S\) is picking a random linear combination of all the rows of \(A\), i.e points in \(\mathbb{R}^d\):</p> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/posts/low-rank-approx-intuition-matrix.webp-480.webp 480w, /assets/img/posts/low-rank-approx-intuition-matrix.webp-800.webp 800w, /assets/img/posts/low-rank-approx-intuition-matrix.webp-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/posts/low-rank-approx-intuition-matrix.webp" class="z-depth-0 center" width="200px" height="auto" style="object-fit: cover" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>This allows us to think of \(SA\) as a \(\frac{k}{\epsilon} \times d\) matrix where we performed this operation \(k/\epsilon\) times. Then each row of \(SA\) is a linear combination of the rows of \(A\), but now in a subspace of only dimension \(k/\epsilon\). If we run SVD on these projected points, we can do it in only \(O \left( n\left( \frac{k}{\epsilon} \right)^2 \right)\) time!</p> <p>To summarize, the main idea is to:</p> <ol> <li>Project all the rows of \(A\) onto a lower dimensional space \(SA\).</li> <li>Find the best rank-\(k\) approximation to the points in \(SA\) via SVD.</li> </ol> <h3 id="choice-of-sketching-matrix">Choice of Sketching Matrix</h3> <p>One might wonder which sketching matrices \(S\) would work for this paradigm. In fact, all of the following sketching matrices work:</p> <ol> <li>\(S\) as the \(\frac{k}{\epsilon} \times n\) matrix of i.i.d normal random variables. We can compute \(SA\) in time \(O\left( \nnz{A} \frac{k}{\epsilon} \right)\) since \(S\) is dense. However, we could do a lot better.</li> <li>\(S\) as the \(\tilde{O}\left(\frac{k}{\epsilon}\right) \times n\) Subsampled Randomized Hadamard Transform (also called the Fast Johnson Lindenstrauss) matrix. \(SA\) can be computed in \(O(nd \log n)\) time.</li> <li>\(S\) as the \(\text{poly}\left( \frac{k}{\epsilon} \right) \times n\) CountSketch matrix. While the number of rows is larger, \(SA\) can be computed in just \(\nnz{A}\) time.</li> </ol> <p>In this post, we will focus on using the CountSketch matrix for low-rank approximation.</p> <h3 id="showing-the-existence-of-a-good-solution-in-the-row-span-of-sa">Showing the Existence of a Good Solution in the Row Span of \(SA\)</h3> <p>For our proposed algorithm to actually work, we must first guarantee that some good rank-\(k\) approximation must live in the row span of \(SA\) in the first place. We will use the following thought experiment to show that such a solution indeed exists. We will not actually attempt to recover the solution.</p> <p>Consider the following hypothetical regression problem:</p> \[\begin{equation}\label{eq:hypothetical-regression} \min _{X}\left\|A_{k} X-A\right\|_{\mathrm{F}}=\left\|A_{k}-A\right\|_{\mathrm{F}}. \end{equation}\] <p>Note again that this is only hypothetical: we don’t know what \(A_k\) is, because if we did, then we are already done!</p> <h4 id="best-solution-to-hypothetical-regression-problem">Best Solution to Hypothetical Regression Problem</h4> <p>The best solution of \(X\) to Equation \ref{eq:hypothetical-regression} is just the identity matrix \(I_d\), since \(A_k\) is already defined to be the best rank-\(k\) approximation to \(A\), and we cannot increase the rank by multiplying something in hopes of further decreasing the Frobenius norm. This gives us</p> \[\begin{equation} \min _{X}\left\|A_{k} X-A\right\|_{\mathrm{F}}=\left\|A_{k}-A\right\|_{\mathrm{F}}. \end{equation}\] <h4 id="sketching-the-hypothetical-regression-problem-with-countsketch">Sketching the Hypothetical Regression Problem with CountSketch</h4> <p>Now take the CountSketch matrix \(S\) to be our affine embedding. We claim that just \(\text{poly} \left( \frac{k}{\epsilon} \right)\) rows suffices, instead of the usual \(\text{poly} \left( \frac{d}{\epsilon} \right)\) rows. This is because since \(A_k\) only has rank \(k\), then we could replace it with some other \(n \times k\) rank \(k\) matrix \(U_k\) that has the same column span as \(A_k\). This works because for every \(X\) there is some \(Y\) such that \(A_{k} X=U_{k} Y\) and vice versa. Thus we can replace \(A_{k}\) with \(U_{k}\) without generality, and \(S\) can be taken as a CountSketch matrix for the smaller matrix \(U_{k}\).</p> <p>Recall our affine embedding result:</p> \[\begin{equation}\label{eq:embedding} \left\|S A_{k} X-S A\right\|_{\mathrm{F}}=(1 \pm \varepsilon)\left\|A_{k} X-A\right\|_{\mathrm{F}}. \end{equation}\] <p>To solve for the \(X\) that minimizes the left hand side quantity, recall that the normal equation gives us</p> \[\begin{equation}\label{eq:normal} \argmin_{X}\left\|S A_{k} X-S A\right\|_{\mathrm{F}}=\left(S A_{k}\right)^{-} S A. \end{equation}\] <p>Plug in Equation \ref{eq:normal} into the right side of \ref{eq:embedding} to obtain</p> \[\begin{equation}\label{eq:exists} \| A_k (SA_k)^- SA - A \|_F \leq (1 \pm \epsilon) \| A_k - A \|_F. \end{equation}\] <p>What is exciting about Equation \ref{eq:exists} is that it tells us that \(A_k (SA_k)^- SA\) is a \((1 \pm \epsilon)\) approximation for \(A_k\). Furthermore, \(A_k (SA_k)^- SA\) is rank-\(k\) and is in the row span of \(SA\), which precisely answers our original question of whether a good rank-\(k\) approximation in the row span of \(SA\) exists in the affirmative!</p> <p>To belabor the point, we do not know either \(A_k\) or \(A_k (SA_k)^- SA\); we simply used them to prove that our desired rank-\(k\) approximation in \(SA\) exists.</p> <h3 id="considering-the-optimal-sketched-solution">Considering the Optimal Sketched Solution</h3> <p>Our conclusion from the previous section allows us to conclude that</p> \[\begin{equation}\label{eq:sketch-1} \min _{\text {rank-} k X}\|X S A-A\|_{\mathrm{F}}^2 \leq\left\|A_{k}\left(S A_{k}\right)^{-} S A-A\right\|_{\mathrm{F}}^2 \leq(1+\varepsilon)\left\|A_{k}-A\right\|_{\mathrm{F}}^2. \end{equation}\] <p>However, solving for the left hand side of Equation \ref{eq:sketch-1} is different from normal regression, because the rank of our solution for \(X\) is constrained. Suppose for a moment that we ignore this rank constraint and proceed to solve for \(X\) as per usual using our normal equations. Then by plugging in the normal equations into Equation \ref{eq:sketch-1}, we obtain</p> \[\begin{equation}\label{eq:pyt-1} \|X S A-A\|_{\mathrm{F}}^{2}= \left\|X S A-A(S A)^{-} S A\right\|_{\mathrm{F}}^{2} + \left\|A(S A)^{-} S A-A\right\|_{\mathrm{F}}^{2} \end{equation}\] <p>by considering the Pythagorean theorem for the elements row-wise: \(X_i SA\) is a projection of \(X_i\) onto \(SA\) in a rank-\(k\) space, and \(A_i (SA)^- SA\) is the projection of \(A_i\) onto \(SA\).</p> <p>Equation \ref{eq:pyt-1} tells us that the second term on the right hand side does not depend on \(X\), so we can re-formulate Equation \ref{eq:sketch-1} as</p> \[\begin{equation}\label{eq:smaller-min} \min _{\text {rank-}k\, X}\|X S A-A\|_{\mathrm{F}}^{2}=\left\|A(S A)^{-} S A-A\right\|_{\mathrm{F}}^{2}+ \min _{\text {rank}-k\, X}\left\|X S A-A(S A)^{-} S A\right\|_{\mathrm{F}}^{2}. \end{equation}\] <h3 id="a-simpler-minimization-problem">A Simpler Minimization Problem</h3> <p>Equation \ref{eq:smaller-min} reduces our original minimization problem to just solving</p> \[\begin{equation} \min _{\text {rank}-k\, X}\left\|X S A-A(S A)^{-} S A\right\|_{\mathrm{F}}^{2}. \end{equation}\] <p>To solve this, let’s begin by writing \(S A=U \Sigma V^{\top}\) in SVD form. We can do this in \(d \cdot \operatorname{poly} \left( \frac{k}{\epsilon} \right)\) time. Then simplify our expression from Equation \ref{eq:smaller-min} to obtain</p> \[\begin{align} &amp; \min _{\text {rank-}k\, X}\left\|X S A-A(S A)^{-} S A\right\|_{\mathrm{F}}^{2} \\ = &amp; \min _{\text {rank}-k\, X}\left\|X U \Sigma V^{\top}-A(S A)^{-} U \Sigma V^{\top}\right\|_{\mathrm{F}}^{2} &amp; \text{(substituting SVD representation of $S$)} \\ = &amp; \min _{\text {rank}-k\, X}\left\|\left(X U \Sigma-A(S A)^{-} U \Sigma\right) V^{\top}\right\|_{\mathrm{F}}^{2} \\ = &amp; \min _{\text {rank}-k\, X}\left\|X U \Sigma-A(S A)^{-} U \Sigma \right\|_{\mathrm{F}}^{2} &amp; \text{($V^\top$ is orthonormal and does not change norm)} \\ = &amp; \min _{\text {rank-k } Y}\left\|Y - A (SA)^- U \Sigma\right\|_{F}^{2}. &amp; \text{(change of variables from $X$ to $Y$, since $U\Sigma$ has full rank)} \\ \end{align}\] <p>This shows that it suffices to just compute the SVD of \(A (SA)^- U \Sigma\) to solve our original problem!</p> <h3 id="issues-with-running-time">Issues with Running Time</h3> <p>Unfortunately, we still haven’t achieved the running time we want. Recall that our goal was to find the best rank-\(k\) approximation in time \({O(\nnz{A} +(n+d) \operatorname{poly}(k / \varepsilon))}\). \(A (SA)^- U \Sigma\) is a \(n \times \text{poly} \left( \frac{k}{\epsilon} \right)\) matrix, so one might claim that computing its SVD only takes \(O\left( n \cdot \text{poly} \left( \frac{k}{\epsilon} \right) \right)\), which is within our time bounds. We could also compute \(SA\), its pseudoinverse \((SA)^-\), and the multiplication \((SA)^-U\Sigma\) quickly.</p> <p>However, the problem is that we cannot multiply on the left by \(A\) within the time bounds, because we have no guarantees about the sparsity of \((SA)^- U \Sigma\). It may as well be a very dense matrix. This means that computing \(A(SA)^- U \Sigma\) takes time at least \(O\left( \nnz{A} \cdot \text{poly}\left( \frac{k}{\epsilon} \right) \right)\), which does not meet our bounds.</p> <h3 id="summary-of-current-progress">Summary of Current Progress</h3> <p>Now is a good time to stop and review the progress that we have made so far. To recap, our current algorithm works as follows:</p> <ol> <li>Compute \(SA\). This is in time \((\nnz{(A)})\)</li> <li>Project each row of \(A\) onto \(SA\). We just showed that we couldn’t do this in our desired time bound \({O\left(\nnz{A} +(n+d) \operatorname{poly}\left( \frac{k}{\epsilon} \right)\right)}\).</li> <li>Find the best rank-\(k\) approximation of the projected points inside the rowspace of \(SA\). This is in time \(O\left( n \cdot \text{poly} \left( \frac{k}{\epsilon} \right) \right)\).</li> </ol> <p>Therefore Step 2 is our bottleneck that we hope to improve. We will do this by approximating the projection of \(A\) onto \(SA\).</p> <h3 id="approximating-the-projection">Approximating the Projection</h3> <p>Projection is in fact just least-squares regression in disguise. This inspires us to sketch again to reduce the dimensions of the problem.</p> <p>Recall that previously we wanted to solve for</p> \[\begin{equation}\label{eq:target} \min _{\text {rank-} k \, X}\|X S A-A\|_{\mathrm{F}}^{2}. \end{equation}\] <p>We can’t sketch on the left anymore since \(X\) appears on the left, so we try to sketch on the right instead. Let \(R\) be an affine embedding matrix, say a transposed CountSketch matrix with \(\text{poly} \cdot \left( \frac{k}{\epsilon} \right)\) columns. Then we sketch on the right in Equation \ref{eq:target} to change our target to be</p> \[\begin{equation}\label{eq:new-target} \min _{\text {rank-} k \, X} \|X (S A) R-A R\|_{\mathrm{F}}^{2}. \end{equation}\] <p>It would be wise to first verify that we can compute all our quantities in the desired bounds. Indeed, computing \(AR\) takes \(\nnz{A}\) time, and computing \(SAR\) can be done in \(\nnz{SA} \leq \nnz{A}\) by recalling that \(SA\) cannot increase the number of non-zero entries in \(A\).</p> <p>Since \(R\) is an affine embedding, by Equation \ref{eq:new-target} we obtain</p> \[\begin{equation}\label{eq:applied} \|X (S A) R-A R\|_{\mathrm{F}}^{2}. =(1 \pm \varepsilon)\|X (S A)-A\|_{\mathrm{F}}^{2}. \end{equation}\] <p>We can rewrite our new target in Equation \ref{eq:new-target} to obtain</p> \[\begin{align} \min _{\text {rank-} k\, X}\|X S A R-A R\|_{\mathrm{F}}^{2} &amp; =\left\|A R(S A R)^{-} S A R-A R\right\|_{\mathrm{F}}^{2}+\min _{\text {rank-}k\, X}\left\|X S A R-A R(S A R)^{-} S A R\right\|_{\mathrm{F}}^{2} \end{align}\] <p>by applying the Pythagorean theorem. Then similarly as before, note that only the second term depends on \(X\), so again we have a smaller minimization problem:</p> \[\begin{equation}\label{eq:change-var} \min _{\text {rank-k } X}\left\|X S A R-A R(S A R)^{-}(S A R)\right\|_{\mathrm{F}}^{2} = \min _{\text {rank-} k\, Y}\left\|Y-A R(S A R)^{-} S A R\right\|_{\mathrm{F}}^{2}, \end{equation}\] <p>where we perform a change of variables to \(Y\). We can do this because the optimal \(Y\) must live in the row space of \(SAR\) and therefore take the form \(XSAR\). Suppose if it did not, then since \(AR(SAR)^-SAR\) is in the row space of \(SAR\), then we could simply remove the orthogonal components to \(SAR\) in \(Y\) to obtain an even better solution, contradicting its optimality.</p> <h3 id="analyzing-the-runtime">Analyzing the Runtime</h3> <p>This time round, we have truly solved the problem. Previously, we failed because we could not project \(A\) onto the column space of \(SA\) in the desired time bounds. But this time round, \(SAR\) has dimensions \(\text{poly} \left( \frac{k}{\epsilon} \right) \times \text{poly} \left( \frac{k}{\epsilon} \right)\), and \(AR\) is a \(n \times \left( \frac{k}{\epsilon} \right)\) matrix that takes \(\nnz{A}\) time to compute, which means that \(AR(SAR)^-(SAR)\) can be computed in time \(n \cdot \text{poly}\left( \frac{k}{\epsilon} \right) \in {O\left(\nnz{A} +(n+d) \operatorname{poly}\left( \frac{k}{\epsilon} \right)\right)}\).</p> <p>As a result, we can proceed to compute \(Y\) in Equation \ref{eq:change-var} by performing truncated SVD in time \(O\left(n \cdot \text{poly} \left( \frac{k}{\epsilon} \right)\right)\).</p> <p>As noted previously, our solution \(Y\) must look like \(Y = XSAR\) for some \(X\). We can thus solve for \(X = Y(SAR)^-\).</p> <p>Then by Equation \ref{eq:target}, the final rank-\(k\) approximation that we wish to return is \(XSA = Y(SAR)^-SA\). A final caveat here is that we must return \(Y(SAR)^-SA\) in factored form, because if we multiply out the matrices it is a \(n \times d\) matrix, which does not fit in our desired running time.</p> <h3 id="returning-the-output-in-factored-form">Returning the Output in Factored Form</h3> <p>We want to output \(LR = Y(SAR)^-SA\) as \(L, R\) where \(L\) is \(n \times k\) and \(R\) is \(k \times d\).</p> <p>To do so, recall that \(Y\) is \(n \times \text{poly} \left( \frac{k}{\epsilon} \right)\) and so we can recover its SVD representation as \(Y = U \Sigma V^\top\). Then let</p> \[\begin{align} L &amp; = U \Sigma, \\ R &amp; = V^\top (SAR)^-SA, \end{align}\] <p>where \(L\) is \(n \times k\) and \(R\) is \(k \times d\). One can check that we can perform all the matrix multiplications within the time bounds.</p> <h3 id="bounding-the-failure-probability">Bounding the Failure Probability</h3> <p>The sketch by \(S\) and \(R\) may both fail to be an affine embedding with some constant probability, say \(\delta = \frac{1}{100}\). Then we can simply union bound over \(S\) and \(R\) failing to show that the construction works with small constant failure probability.</p> <h3 id="summary">Summary</h3> <p>That was a lot of discussion and analysis, but in the end, the low-rank approximation algorithm is very simple.</p> <ol> <li>Compute \(SA\).</li> <li>Compute \(SAR\) and \(AR\).</li> <li>Compute \(\argmin_Y \left\|Y-A R(S A R)^{-}(S A R)\right\|_{\mathrm{F}}^{2}\) by truncated SVD.</li> <li>Output \(Y(SAR)^{-}SA\) in factored form.</li> </ol> <p>This takes \(O\left(\nnz{A}+(n+d) \text{poly} \left( \frac{k}{\epsilon} \right) \right)\) time overall, which is much faster than applying truncated SVD to \(A\) directly.</p> <h2 id="references">References</h2> <ul> <li>Kenneth L. Clarkson and David P. Woodruff. Low rank approximation and regression in input sparsity time. CoRR, abs/1207.6365, 2012. URL: <a href="http://arxiv.org/abs/1207.6365" rel="external nofollow noopener" target="_blank">http://arxiv.org/abs/1207.6365</a>, arXiv:1207.6365.</li> <li>Tamas Sarlos. Improved approximation algorithms for large matrices via random projections. In 2006 47th Annual IEEE Symposium on Foundations of Computer Science (FOCS’06), pages 143–152, 2006. doi:10.1109/FOCS.2006.37.</li> </ul> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <p class="mb-2">Related Posts:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/llama-3.1-technical-report-notes/">Notes on 'The Llama 3 Herd of Models'</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/setting-up-yuancon-controller-sound-voltex/">Playing Sound Voltex at Home: Setting Up Unnamed SDVX Clone with the Yuancon SDVX Controller</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/creating-trackback-requests/">Creating Trackback Requests for Static Sites</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/high-dimensional-analysis-of-m-estimators/">A Unified Framework for High-Dimensional Analysis of M-Estimators with Decomposable Regularizers: A Guided Walkthrough</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/cmu-steam-tunnels/">The CMU Steam Tunnels and Wean 9</a> </li> <div id="giscus_thread" style="max-width: 930px; margin: 0 auto;"> <script>
      let giscusTheme = determineComputedTheme();
      let giscusAttributes = {
        src: 'https://giscus.app/client.js',
        'data-repo': 'fanpu/fanpu.github.io',
        'data-repo-id': '',
        'data-category': 'Comments',
        'data-category-id': '',
        'data-mapping': 'title',
        'data-strict': '1',
        'data-reactions-enabled': '1',
        'data-emit-metadata': '0',
        'data-input-position': 'bottom',
        'data-theme': giscusTheme,
        'data-lang': 'en',
        crossorigin: 'anonymous',
        async: '',
      };

      let giscusScript = document.createElement('script');
      Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value));
      document.getElementById('giscus_thread').appendChild(giscusScript);
    </script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Fan Pu Zeng. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Last updated: January 02, 2025. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script src="/assets/js/tooltips-setup.js?53023e960fbc64cccb90d32e9363de2b"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?70d799092f862ad98c7876aa47712e20"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-S3VHEYH05S"></script> <script defer src="/assets/js/google-analytics-setup.js?12374742c4b1801ba82226e617af7e2d"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>